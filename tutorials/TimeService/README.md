# TimeService - Async Messaging #

## What You Learn ##

*   How to write an application service acting as a so called inbound-port 
*   How to declare an outbound-port sending current time (which represents some kind of measuring point)    
*   How to provide an implementation of this outbound-port, a so called driving adapter, with console output
*   How to provide an implementation of this outbound-port using `DrivenAdapterStrategy` from Jexxa for JMS.
*   How to use a so called `specific adapter` provided by Jexxa together with an application specific driving adapter    

## What you need ##

*   Understand tutorial `HelloJexxa` because we explain only new aspects 
*   60 minutes
*   JDK 11 (or higher) installed 
*   Maven 3.6 (or higher) installed
*   A running ActiveMQ instance (at least if you start the application with option `-jms`)
*   curl or jconsole to trigger the application  

## Implement the Application Core ##

The application core consists of following two classes:

*   `TimeService:` Provides use cases of the domain and is a `ApplicationService` in terms of the pattern language of DDD
*   `ITimePublisher:` Allows for publishing current time and is a `DomainService` in terms of the pattern language of DDD
*   `IMessageDisplay:` Shows a message and is a `DomainService` in terms of the pattern language of DDD        
  
### Implement class `TimeService` ###

This class provides the supports the main two very simple use cases of this application: 
*   Provide current time
*   Publish current time in any way.   

The most important aspect here is that a technology-agnostic application must not use any technology-stack. Therefore, 
we must define an interface `ITimePublisher` that provides us the possibility to publish the time by an arbitrary technology stack.

Since Jexxa only supports implicit constructor injection, we have to declare all required interfaces in the constructor.    

```java
public class TimeService
{
    private final ITimePublisher timePublisher;
    private final IMessageDisplay messageDisplay;

    /**
     * Note: Jexxa supports only implicit constructor injection. Therefore, we must
     * declare all required interfaces in the constructor.  
     *
     * @param timePublisher required outbound port for this application service
     * @param messageDisplay required outbound port for this application service
     */
    public TimeService(ITimePublisher timePublisher, IMessageDisplay messageDisplay)
    {
        Objects.requireNonNull(timePublisher);
        Objects.requireNonNull(messageDisplay);

        this.timePublisher = timePublisher;
        this.messageDisplay = messageDisplay;
    }

    public LocalTime getTime()
    {
        return LocalTime.now();
    }

    public void publishTime()
    {
        timePublisher.publish(getTime());
    }


    /**
     * This method shows the previously published time.
     * @param localTime the previously published time
     */
    public void displayPublishedTimed(LocalTime localTime)
    {
        var messageWithPublishedTime = "New Time was published, time: " + localTime.format(DateTimeFormatter.ISO_TIME);
        messageDisplay.show(messageWithPublishedTime);
    }

}
```                  

### Declare interface `ITimePublisher` ###

The interface is quite simple since we need just a single method to publish a time. 

```java
public interface ITimePublisher
{
    void publish(LocalTime localTime);
}
```                 

### Declare interface `IMessageDisplay` ###

```java
public interface IMessageDisplay
{
    void show(String message);
}
```                 
 
## Implement the Infrastructure ##

### Driven Adapter with console output ###
The implementation is quite simple and just prints given arguments to a logger.  

Note: Jexxa uses implicit constructor injection together with a strict convention over configuration approach.

Therefore, each driven adapter needs one of the following constructors: 

*   A public default constructor
*   A public constructor with a single `Properties` attribute
*   A public static factory method that gets no parameters and returns the type of the driving adapter
*   A public static factory method with a single `Properties` parameter and returns the type of the requested driving adapter
   
Since our driven adapter does not need/support any configuration parameter, we can use default constructor generated by Java.

Note: In case you use any static code analysis tools such as SonarCube you can add annotation `@SuppressWarnings("unused")` to avoid a warning such as "class is not used". 

```java
@SuppressWarnings("unused")
public class MessageDisplay implements IMessageDisplay
{
    @Override
    public void show(String message)
    {
        JexxaLogger.getLogger(MessageDisplay.class).info(message);
    }
}
```

### Driven Adapter for messaging ###

Jexxa provides so called `DrivenAdapterStrategy` for various Java-APIs such as JMS. When using these strategies the implementation of a driven adapter 
is just a facade and maps domain specific methods to the technology stack. In the main application we can adjust the default strategy so that we can 
define either to use JMS or a simple logger. Moreover, within tests, we can define a MessageRecorder and uint-test our infrastructure as well.  

Note: Since `TimePublisher` requires information from a `Properties` we must provide a constructor or static factory method with a `Properties` attribute. By default, Jexxa hands in all information from jexxa-application.properties file. This file can extended by application specific information such as the topic name if required.

In this example, sending a time is just a representation for any kind of measuring point. In real world applications this kind of information has no additional semantic meaning. Typically, it is also send in a fixed interval. So, we just have to define a notation to publish this information. The 
following code shows how to publish a LocalTime in JSON format.                

```java
@SuppressWarnings("unused")
public class TimePublisher implements ITimePublisher
{
    public static final String TIME_TOPIC = "TimeService";

    private final MessageSender messageSender;

    // For all driven adapter we have to provide either a static factory or a public constructor to
    // enable implicit constructor injection
    public TimePublisher(Properties properties)
    {
        //Request a default message Sender from corresponding strategy manager
        this.messageSender = MessageSenderManager.getMessageSender(properties);
    }

    @Override
    public void publish(LocalTime localTime)
    {
        // Send the message to the topic in JSON format.
        messageSender.send(localTime)
                .toTopic(TIME_TOPIC)
                .asJson();
    }
}
```

Typically, information stated in `jexxa-application.properties` for JMS are as follows: 

```properties
#suppress inspection "UnusedProperty" for whole file
#Settings for JMSAdapter and JMSSender
java.naming.factory.initial=org.apache.activemq.jndi.ActiveMQInitialContextFactory
java.naming.provider.url=tcp://localhost:61616
java.naming.user=admin
java.naming.password=admin
```                       

## Implement the port adapter to receive JMS messages ##
When receiving asynchronous messages we have to convert it into business data which is defined in the application core and forward it to a specific method within the application core. Since this cannot be done by convention meaningful, we have to use a configuration approach. As described in [Architecture of Jexxa](https://repplix.github.io/Jexxa/jexxa.html), we have to implement a so called port adapter.   
  
Implementing a port adapter for JMS is quite easy.
*   Within the constructor we define our class from the application core that will be called. Jexxa automatically injects this object when creating the port adapter. By convention, this is the only object defined in the constructor.  
*   In case of JMS we have to implement the JMS specific `MessageListener` interface. To facilitate this, Jexxa offers convenience classes which perform JSON deserialization.  
*   Finally, we have to pass the configuration parameter the specific driving adapter. In this case it is called `JMSConfiguration` and allows to define all JMS related information, such as destination, messaging type, and a messaging selector if required.            
  
```java
@SuppressWarnings("unused")
public final class PublishTimeListener extends TypedMessageListener<LocalTime>
{
    private final TimeService timeService;
    private static final String TIME_TOPIC = "TimeService";

    //To implement a so called PortAdapter we need a public constructor which expects a single argument that must be a InboundPort.
    public PublishTimeListener(TimeService timeService)
    {
        super(LocalTime.class);
        this.timeService = timeService;
    }

    @Override
    // The JMS specific configuration is defined via annotation.
    @JMSConfiguration(destination = TIME_TOPIC,  messagingType = TOPIC)
    public void onMessage(LocalTime localTime)
    {
        // Forward this information to corresponding application service.
        timeService.displayPublishedTime(localTime);
    }
}
```

## Implement the Application ##

Finally, we have to write our application. As you can see in the code below there are two main differences compared to `HelloJexxa`:

*   We define the packages that should be used by Jexxa. This allows fine-grained control of used driven adapter since we must offer only a single implementation for each outbound port. In addition, this limits the search space for potential driven adapters and speeds up startup time.
*   Depending on the command line parameters we decide which driven adapter should be used to publish the time, JMS based or console based.
*   In case we use JMS, we connect JMSAdapter to the application specific port adapter.     
*   The rest of the main method is similar to `HelloJexxa` tutorial.   
   
```java
public final class TimeServiceApplication
{
    //Declare the packages that should be used by Jexxa
    private static final String DRIVEN_ADAPTER  = TimeServiceApplication.class.getPackageName() + ".infrastructure.drivenadapter";
    private static final String DRIVING_ADAPTER = TimeServiceApplication.class.getPackageName() + ".infrastructure.drivingadapter";
    private static final String OUTBOUND_PORTS  = TimeServiceApplication.class.getPackageName() + ".domainservice";

    public static void main(String[] args)
    {
        // Define the default strategy for messaging which is either a simple logger called `MessageLogger.class` or `JMSSender.class` for JMS messages
        MessageSenderManager.setDefaultStrategy(getMessagingStrategy(args));

        //Create your jexxaMain for this application
        JexxaMain jexxaMain = new JexxaMain("TimeService");

        jexxaMain
                //Define which outbound ports should be managed by Jexxa
                .addToApplicationCore(OUTBOUND_PORTS)
                .addToInfrastructure(DRIVEN_ADAPTER)
                //Note: Since we provide our own special driving adapters, we have to add it to the infrastructure
                .addToInfrastructure(DRIVING_ADAPTER)

                // Bind RESTfulRPCAdapter and JMXAdapter to TimeService class so that we can invoke its method
                .bind(RESTfulRPCAdapter.class).to(TimeService.class)
                .bind(JMXAdapter.class).to(TimeService.class)


                // Conditional bind is only executed if given expression evaluates to true
                .conditionalBind( TimeServiceApplication::isJMSEnabled, JMSAdapter.class).to(PublishTimeListener.class)

                .bind(JMXAdapter.class).to(jexxaMain.getBoundedContext())

                .start()

                .waitForShutdown()

                .stop();
    }
}
```  

That's it. 

## Run the Application with console output ##

```console                                                          
mvn clean install
java -jar target/timeservice-jar-with-dependencies.jar 
```
You will see following (or similar) output
```console
[main] INFO io.jexxa.core.JexxaMain - Start BoundedContext 'TimeService' with 2 Driving Adapter 
[main] INFO org.eclipse.jetty.util.log - Logging initialized @644ms to org.eclipse.jetty.util.log.Slf4jLog
[main] INFO io.javalin.Javalin - Starting Javalin ...
[main] INFO io.javalin.Javalin - Listening on http://localhost:7500/
[main] INFO io.javalin.Javalin - Javalin started in 121ms \o/
[main] INFO io.jexxa.core.JexxaMain - BoundedContext 'TimeService' successfully started in 0.649 seconds
```          

### Publish the time  with console output ###

You can use curl to publish the time.  
```Console
curl -X POST http://localhost:7500/TimeService/publishTime
```

Each time you execute curl you should see following output on the console: 

```console                                                          
[qtp380242442-31] INFO io.jexxa.infrastructure.drivenadapterstrategy.messaging.logging.MessageLogger - Begin> Send message
[qtp380242442-31] INFO io.jexxa.infrastructure.drivenadapterstrategy.messaging.logging.MessageLogger - Message           : {"hour":17,"minute":12,"second":34,"nano":873658000}
[qtp380242442-31] INFO io.jexxa.infrastructure.drivenadapterstrategy.messaging.logging.MessageLogger - Destination       : TimeService
[qtp380242442-31] INFO io.jexxa.infrastructure.drivenadapterstrategy.messaging.logging.MessageLogger - Destination-Type  : TOPIC
[qtp380242442-31] INFO io.jexxa.infrastructure.drivenadapterstrategy.messaging.logging.MessageLogger - End> Send message
```

## Run the Application with JMS ##

```console                                                          
mvn clean install
java -jar target/timeservice-jar-with-dependencies.jar -J 
```
You will see following (or similar) output
```console
[main] INFO io.jexxa.core.JexxaMain - Start BoundedContext 'TimeService' with 2 Driving Adapter 
[main] INFO org.eclipse.jetty.util.log - Logging initialized @644ms to org.eclipse.jetty.util.log.Slf4jLog
[main] INFO io.javalin.Javalin - Starting Javalin ...
[main] INFO io.javalin.Javalin - Listening on http://localhost:7500/
[main] INFO io.javalin.Javalin - Javalin started in 121ms \o/
[main] INFO io.jexxa.core.JexxaMain - BoundedContext 'TimeService' successfully started in 0.649 seconds
```          

### Publish the time with JMS ###
 
You can use curl to publish the time.  
```Console
curl -X POST http://localhost:7500/TimeService/publishTime
```

Each time you execute curl you should see following output on the console: 

```console                                                          
[ActiveMQ Session Task-1] INFO io.jexxa.tutorials.timeservice.infrastructure.drivenadapter.display.MessageDisplay - New Time was published, time: 17:15:18.743772
```
